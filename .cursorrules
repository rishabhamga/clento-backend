---
description: Clento Backend Service Coding Standards
globs: "**/*.{js,ts}"
alwaysApply: true
---

# Clento Backend Coding Standards

## **Code Structure and Organization**
- **Keep Functions Small and Focused**
  - Functions should do one thing and do it well
  - Aim for less than 15 lines per function
  - Extract complex logic into separate helper functions

- **Naming Conventions**
  - Use descriptive, meaningful names for variables, functions, and classes
  - Controllers should end with `Controller` suffix
  - Services should end with `Service` suffix
  - DTOs should end with `Dto` suffix
  - Repositories should end with `Repository` suffix

- **File Organization**
  - One class/component per file
  - Group related files in directories by feature
  - Keep directory structure flat when possible

## **Code Quality**
- **Minimize Code Complexity**
  - Prefer simple, readable code over clever solutions
  - Avoid deep nesting (maximum 3 levels)
  - Use early returns to reduce nesting

- **Error Handling**
  - Use custom error classes for different error types
  - Always catch and properly handle errors
  - Provide meaningful error messages

- **Asynchronous Code**
  - Use async/await over Promise chains
  - Handle promise rejections properly
  ```typescript
  // ‚úÖ DO: Use async/await with proper error handling
  async function getData() {
    try {
      const result = await fetchData();
      return result;
    } catch (error) {
      logger.error('Failed to fetch data', error);
      throw new AppError('Failed to fetch data', 500);
    }
  }

  // ‚ùå DON'T: Use unhandled promises or complex chains
  function getData() {
    return fetchData()
      .then(result => processResult(result))
      .then(processed => {
        // Complex logic here
      });
  }
  ```

## **API Design**
- **RESTful Principles**
  - Use appropriate HTTP methods (GET, POST, PUT, DELETE)
  - Return appropriate status codes
  - Use consistent URL patterns

- **Swagger Documentation**
  - Document all API endpoints with Swagger annotations
  - Include request/response examples
  - Document all possible response status codes

- **Request Validation**
  - Validate all incoming requests using DTOs
  - Return clear validation error messages

## **Database Access**
- **Repository Pattern**
  - Use repositories to abstract database access
  - Keep SQL queries in repositories, not in services
  - Use parameterized queries to prevent SQL injection

- **Transaction Management**
  - Use transactions for operations that modify multiple records
  - Ensure proper error handling within transactions

## **Security**
- **Authentication and Authorization**
  - Use Clerk for authentication
  - Implement proper authorization checks
  - Never expose sensitive data in responses

- **Input Sanitization**
  - Sanitize all user inputs
  - Use parameterized queries for database operations
  - Validate request payloads against schemas

## **Testing**
- **Unit Tests**
  - Write tests for all business logic
  - Mock external dependencies
  - Aim for high code coverage

- **Integration Tests**
  - Test API endpoints with real HTTP requests
  - Use separate test database

## **Performance**
- **Optimize Database Queries**
  - Use indexes for frequently queried columns
  - Avoid N+1 query problems
  - Use pagination for large result sets

- **Caching**
  - Cache frequently accessed, rarely changing data
  - Use appropriate cache invalidation strategies

## **Logging**
- **Structured Logging**
  - Use structured logging format (JSON)
  - Include relevant context in log entries
  - Use appropriate log levels (debug, info, warn, error)

- **Error Logging**
  - Log all errors with stack traces
  - Include request context in error logs
  - Don't log sensitive information

## **Configuration**
- **Environment Variables**
  - Use environment variables for configuration
  - Provide sensible defaults
  - Validate required environment variables on startup

## **API Development - MANDATORY ClentoAPI Usage**

### **üö® CRITICAL: Always Use ClentoAPI Class**
- **NEVER create manual Express routes** - Always use ClentoAPI base class
- **NEVER use traditional controller pattern** - Use ClentoAPI for all API endpoints
- **NEVER manually bind middleware** - Use ClentoAPI.createRouter() for automatic setup
- **ALL API endpoints MUST extend ClentoAPI** - No exceptions

### **Required API Structure**
```typescript
// ‚úÖ CORRECT: Always use this pattern
export class YourAPI extends ClentoAPI {
  public path = '/api/your-endpoint';
  public authType:'DASHBOARD' = 'DASHBOARD'; // or 'NONE', 'API'

  constructor() {
    super();
    // Configure request parameters
    this.requestParams = {
      GET: { bodyParams: {}, queryParams: {}, pathParams: {} },
      POST: { bodyParams: { name: 'required' }, queryParams: {}, pathParams: {} },
      // ... other methods
    };
  }

  public GET = async (req: Request, res: Response): Promise<void> => {
    // Your business logic here
    res.status(200).json({ success: true, data: result });
  };
}

// ‚úÖ CORRECT: Always use createRouter for automatic setup
export default ClentoAPI.createRouter(YourAPI, {
  GET: '/endpoint',
  POST: '/endpoint',
  PUT: '/endpoint/:id'
});
```

### **‚ùå FORBIDDEN Patterns**
```typescript
// ‚ùå NEVER: Manual Express routes
const router = Router();
router.get('/endpoint', (req, res) => { ... });

// ‚ùå NEVER: Traditional controllers
export class YourController {
  getEndpoint = async (req, res) => { ... }
}

// ‚ùå NEVER: Manual middleware binding
router.get('/endpoint', authMiddleware, yourController.getEndpoint);
```

### **File Organization Rules**
- **API classes go in `/src/routes/`** - Not in `/src/controllers/`
- **One file per API feature** - `[featureName]Routes.ts`
- **Each file contains**: API class + automatic router export
- **File naming**: `userRoutes.ts`, `leadListRoutes.ts`, etc.

### **Authentication Types**
- **`NONE`**: Public endpoints (no auth required)
- **`API`**: API key authentication
- **`DASHBOARD`**: Full dashboard authentication (most common)

### **Request Parameter Validation**
```typescript
this.requestParams = {
  GET: {
    bodyParams: {},
    queryParams: { page: 'optional', limit: 'optional' },
    pathParams: {},
  },
  POST: {
    bodyParams: { name: 'required', email: 'required' },
    queryParams: {},
    pathParams: {},
  },
  PUT: {
    bodyParams: { name: 'optional' },
    queryParams: {},
    pathParams: { id: 'required' },
  },
};
```

### **Response Format Standards**
```typescript
// ‚úÖ Success responses
res.status(200).json({
  success: true,
  data: result,
  message: 'Operation completed successfully'
});

// ‚úÖ Error responses (handled automatically by ClentoAPI)
throw new ValidationError('Invalid input');
throw new AppError('Something went wrong', 500);
```

### **Swagger Documentation Requirements**
- **Every API method MUST have Swagger documentation**
- **Include summary, tags, security, requestBody, responses**
- **Document all possible status codes**
- **Place documentation directly above each method**
- **When creating new Swagger documentation files, always place the documentation at the bottom of the file**

### **Integration with Main App**
```typescript
// In /src/routes/index.ts
import yourFeatureRoutes from './yourFeatureRoutes';

router.use('/your-feature', yourFeatureRoutes);
```

### **Migration Rules**
- **When updating existing APIs**: Convert to ClentoAPI pattern
- **When creating new APIs**: Always use ClentoAPI from the start
- **When refactoring**: Replace manual routes with ClentoAPI.createRouter()

## **Coding**
- **writing new code**
  - Before writing any new code, scan in the repo if we already have some code for it, do not just blindly create new code, verify if that can be used by modifying a little.
  - When you modify a existing code for new functionality, verify it that code is being use somewhere and does not break that

- **Code Cleanup**
  - Remove unused code, files, and dependencies
  - Delete old implementations when replacing with new ones
  - Always verify code is not used elsewhere before removing it
  - Keep imports clean by removing unused imports
  - Remove commented out code that is no longer needed
  - Document why code is kept if it appears unused but serves a purpose