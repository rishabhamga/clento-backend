---
description: Clento Backend Service Coding Standards
globs: "**/*.{js,ts}"
alwaysApply: true
---

# Clento Backend Coding Standards

## **Code Structure and Organization**
- **Indentation**
  - Use 4 spaces for indentation (never tabs)
  - Maintain consistent indentation throughout the codebase
  - Configure your editor to show whitespace characters

- **Keep Functions Small and Focused**
  - Functions should do one thing and do it well
  - Aim for less than 15 lines per function
  - Extract complex logic into separate helper functions

- **Naming Conventions**
  - Use descriptive, meaningful names for variables, functions, and classes
  - Controllers should end with `Controller` suffix
  - Services should end with `Service` suffix
  - DTOs should end with `Dto` suffix
  - Repositories should end with `Repository` suffix

- **File Organization**
  - One class/component per file
  - Group related files in directories by feature
  - Keep directory structure flat when possible

## **Code Quality**
- **Minimize Code Complexity**
  - Prefer simple, readable code over clever solutions
  - Avoid deep nesting (maximum 3 levels)
  - Use early returns to reduce nesting

- **Error Handling**
  - Use custom error classes for different error types
  - Always catch and properly handle errors
  - Provide meaningful error messages

- **Asynchronous Code**
  - Use async/await over Promise chains
  - Handle promise rejections properly
  ```typescript
  // ‚úÖ DO: Use async/await with proper error handling
  async function getData() {
    try {
      const result = await fetchData();
      return result;
    } catch (error) {
      logger.error('Failed to fetch data', error);
      throw new AppError('Failed to fetch data', 500);
    }
  }

  // ‚ùå DON'T: Use unhandled promises or complex chains
  function getData() {
    return fetchData()
      .then(result => processResult(result))
      .then(processed => {
        // Complex logic here
      });
  }
  ```

## **API Design**
- **RESTful Principles**
  - Use appropriate HTTP methods (GET, POST, PUT, DELETE)
  - Return appropriate status codes
  - Use consistent URL patterns

- **Swagger Documentation**
  - Document all API endpoints with Swagger annotations
  - Include request/response examples
  - Document all possible response status codes

- **Request Validation**
  - Validate all incoming requests using DTOs
  - Return clear validation error messages

## **Database Access**
- **Repository Pattern**
  - Use repositories to abstract database access
  - Keep SQL queries in repositories, not in services
  - Use parameterized queries to prevent SQL injection

- **Transaction Management**
  - Use transactions for operations that modify multiple records
  - Ensure proper error handling within transactions

## **Security**
- **Authentication and Authorization**
  - Use Clerk for authentication
  - Implement proper authorization checks
  - Never expose sensitive data in responses

- **Input Sanitization**
  - Sanitize all user inputs
  - Use parameterized queries for database operations
  - Validate request payloads against schemas

## **Testing**
- **Unit Tests**
  - Write tests for all business logic
  - Mock external dependencies
  - Aim for high code coverage

- **Integration Tests**
  - Test API endpoints with real HTTP requests
  - Use separate test database

## **Performance**
- **Optimize Database Queries**
  - Use indexes for frequently queried columns
  - Avoid N+1 query problems
  - Use pagination for large result sets

- **Caching**
  - Cache frequently accessed, rarely changing data
  - Use appropriate cache invalidation strategies

## **Logging**
- **Structured Logging**
  - Use structured logging format (JSON)
  - Include relevant context in log entries
  - Use appropriate log levels (debug, info, warn, error)

- **Error Logging**
  - Log all errors with stack traces
  - Include request context in error logs
  - Don't log sensitive information

## **Configuration**
- **Environment Variables**
  - Use environment variables for configuration
  - Provide sensible defaults
  - Validate required environment variables on startup

## **API Development - MANDATORY ClentoAPI Usage**

### **üö® CRITICAL: Always Use ClentoAPI Class**
- **NEVER create manual Express routes** - Always use ClentoAPI base class
- **NEVER use traditional controller pattern** - Use ClentoAPI for all API endpoints
- **NEVER manually bind middleware** - Use ClentoAPI.createRouter() for automatic setup
- **ALL API endpoints MUST extend ClentoAPI** - No exceptions

### **Required API Structure**
```typescript
// ‚úÖ CORRECT: Always use this pattern
export class YourAPI extends ClentoAPI {
  public path = '/api/your-endpoint';
  public authType:'DASHBOARD' = 'DASHBOARD'; // or 'NONE', 'API'

  constructor() {
    super();
    // Configure request parameters
    this.requestParams = {
      GET: { bodyParams: {}, queryParams: {}, pathParams: {} },
      POST: { bodyParams: { name: 'required' }, queryParams: {}, pathParams: {} },
      // ... other methods
    };
  }

  public GET = async (req: Request, res: Response): Promise<void> => {
    // Your business logic here
    res.status(200).json({ success: true, data: result });
  };
}

// ‚úÖ CORRECT: Always use createRouter for automatic setup
export default ClentoAPI.createRouter(YourAPI, {
  GET: '/endpoint',
  POST: '/endpoint',
  PUT: '/endpoint/:id'
});
```

### **‚ùå FORBIDDEN Patterns**
```typescript
// ‚ùå NEVER: Manual Express routes
const router = Router();
router.get('/endpoint', (req, res) => { ... });

// ‚ùå NEVER: Traditional controllers
export class YourController {
  getEndpoint = async (req, res) => { ... }
}

// ‚ùå NEVER: Manual middleware binding
router.get('/endpoint', authMiddleware, yourController.getEndpoint);
```

### **File Organization Rules**
- **API classes go in `/src/routes/`** - Not in `/src/controllers/`
- **One file per API feature** - `[featureName]Routes.ts`
- **Each file contains**: API class + automatic router export
- **File naming**: `userRoutes.ts`, `leadListRoutes.ts`, etc.

### **Authentication Types**
- **`NONE`**: Public endpoints (no auth required)
- **`API`**: API key authentication
- **`DASHBOARD`**: Full dashboard authentication (most common)

### **Request Parameter Validation**
```typescript
this.requestParams = {
  GET: {
    bodyParams: {},
    queryParams: { page: 'optional', limit: 'optional' },
    pathParams: {},
  },
  POST: {
    bodyParams: { name: 'required', email: 'required' },
    queryParams: {},
    pathParams: {},
  },
  PUT: {
    bodyParams: { name: 'optional' },
    queryParams: {},
    pathParams: { id: 'required' },
  },
};
```

### **Response Format Standards**
```typescript
// ‚úÖ Success responses
res.status(200).json({
  success: true,
  data: result,
  message: 'Operation completed successfully'
});

// ‚úÖ Error responses (handled automatically by ClentoAPI)
throw new ValidationError('Invalid input');
throw new AppError('Something went wrong', 500);
```

### **Swagger Documentation Requirements**
- **Every API method MUST have Swagger documentation**
- **Include summary, tags, security, requestBody, responses**
- **Document all possible status codes**
- **Place documentation directly above each method**
- **When creating new Swagger documentation files, always place the documentation at the bottom of the file**

### **Integration with Main App**
```typescript
// In /src/routes/index.ts
import yourFeatureRoutes from './yourFeatureRoutes';

router.use('/your-feature', yourFeatureRoutes);
```

### **Migration Rules**
- **When updating existing APIs**: Convert to ClentoAPI pattern
- **When creating new APIs**: Always use ClentoAPI from the start
- **When refactoring**: Replace manual routes with ClentoAPI.createRouter()

## **üöÄ Pocketly-Style Routing Pattern (MANDATORY)**

### **CRITICAL: Always Use Pocketly-Style Routing**
- **NEVER create manual Express routes** - Always use ClentoAPI base class
- **NEVER use traditional controller pattern** - Use ClentoAPI for all API endpoints
- **NEVER manually bind middleware** - Routes are automatically discovered and registered
- **ALL API endpoints MUST extend ClentoAPI** - No exceptions
- **NO constructor setup required** - Clean class definitions only

### **Required API Structure (Pocketly Style)**
```typescript
// ‚úÖ CORRECT: Always use this pattern
import ClentoAPI from '../utils/apiUtil';
import { Request, Response } from 'express';
import '../utils/expressExtensions'; // Import extensions

class YourAPI extends ClentoAPI {
  public path = '/api/your-endpoint';
  public authType: 'DASHBOARD' = 'DASHBOARD'; // or 'NONE', 'API'

  private yourService = new YourService();

  public GET = async (req: Request, res: Response): Promise<Response> => {
    // Your business logic here
    return res.sendOKResponse({ data: result });
  };

  public POST = async (req: Request, res: Response): Promise<Response> => {
    // Your business logic here
    return res.sendOKResponse({ data: result });
  };
}

export default new YourAPI();
```

### **‚ùå FORBIDDEN Patterns**
```typescript
// ‚ùå NEVER: Manual Express routes
const router = Router();
router.get('/endpoint', (req, res) => { ... });

// ‚ùå NEVER: Traditional controllers
export class YourController {
  getEndpoint = async (req, res) => { ... }
}

// ‚ùå NEVER: Manual middleware binding
router.get('/endpoint', authMiddleware, yourController.getEndpoint);

// ‚ùå NEVER: Constructor setup
constructor() {
  super();
  this.requestParams = { ... };
}
```

### **File Organization Rules**
- **API classes go in `/src/routes/`** - Not in `/src/controllers/`
- **One file per API feature** - `[featureName].ts` (flat structure)
- **Each file contains**: API class + automatic export
- **File naming**: `userProfile.ts`, `leadListMain.ts`, `campaignCreate.ts`, etc.
- **NO nested directories** - Keep routes flat like Pocketly

### **Authentication Types**
- **`NONE`**: Public endpoints (no auth required)
- **`API`**: API key authentication
- **`DASHBOARD`**: Full dashboard authentication (most common)

### **Automatic Route Registration**
- Routes are **automatically discovered** when server starts
- **No manual registration** required
- Just create the file and it works immediately
- Uses `registerAllRoutes()` in `src/index.ts`

## **üìù Parameter Validation with Express Extensions**

### **Request Body Access**
```typescript
// ‚úÖ CORRECT: Use getBody() for request body
const body = req.getBody();
const name = body.getParamAsString('name', true); // required
const email = body.getParamAsString('email', false); // optional
```

### **Query Parameters Access**
```typescript
// ‚úÖ CORRECT: Use getQuery() for query parameters
const query = req.getQuery();
const page = query.getParamAsNumber('page', false);
const limit = query.getParamAsNumber('limit', false);
```

### **Path Parameters Access**
```typescript
// ‚úÖ CORRECT: Use getPathParams() for URL parameters
const params = req.getPathParams();
const userId = params.getParamAsString('userId', true);
```

### **File Upload Access**
```typescript
// ‚úÖ CORRECT: Use getFiles() for file uploads
const files = req.getFiles();
const csvFile = files.getFileAsCSV('csvFile', true);
const imageFile = files.getFileAsJPG('image', false);
```

### **Available Parameter Methods**
```typescript
// String parameters
body.getParamAsString('name', true); // required
body.getParamAsString('description', false); // optional

// String arrays
body.getParamAsStringArray('tags', true);
body.getParamAsStringArray('emails', false);

// Numbers
body.getParamAsNumber('age', true);
body.getParamAsNumber('count', false);

// Booleans
body.getParamAsBoolean('isActive', true);
body.getParamAsBoolean('isPublic', false);

// Dates
body.getParamAsDate('startDate', true);
body.getParamAsDate('endDate', false);

// UUIDs
body.getParamAsUUID('userId', true);
body.getParamAsUUID('orgId', false);

// Emails
body.getParamAsEmail('email', true);
body.getParamAsEmail('backupEmail', false);

// Enums
body.getParamAsEnumValue(MyEnum, 'status', true);
body.getParamAsEnumValue(MyEnum, 'type', false);

// Enum arrays
body.getParamAsEnumArray(MyEnum, 'categories', true);

// Nested objects
const settings = body.getParamAsNestedBody('settings', true);
const nestedValue = settings.getParamAsString('theme', false);

// Arrays of nested objects
const items = body.getParamAsArrayOfNestedBodies('items', true);
items.forEach(item => {
  const name = item.getParamAsString('name', true);
});
```

### **File Upload Methods**
```typescript
// CSV files
const csvFile = files.getFileAsCSV('csvFile', true);

// Image files
const pngFile = files.getFileAsPNG('image', true);
const jpgFile = files.getFileAsJPG('photo', false);

// Generic file
const anyFile = files.getFile('document');
```

## **üîß Response Methods**

### **Success Responses**
```typescript
// ‚úÖ Standard success response
return res.sendOKResponse({ data: result });

// ‚úÖ Created resource response
return res.sendCreatedResponse({ id: newId, data: result });

// ‚úÖ No content response
return res.sendNoContentResponse();
```

### **Error Responses**
```typescript
// ‚úÖ Custom error response
return res.sendErrorResponse(400, 'Invalid input', { field: 'email' });

// ‚úÖ Validation error response
return res.sendValidationError('Email is required');
```

## **üîÑ Migration Rules**

### **When Updating Existing APIs**
- Convert to Pocketly-style ClentoAPI pattern
- Remove manual route registration
- Remove constructor setup
- Use express extensions for parameter validation

### **When Creating New APIs**
- Always use ClentoAPI from the start
- Follow flat file structure
- Use automatic route discovery

## **üéØ Pocketly Compatibility**

### **Benefits Achieved**
- **Exact same pattern** as your Pocketly system
- **No learning curve** - works exactly as you expect
- **Consistent codebase** across your projects
- **Automatic route discovery** - routes appear when files are created
- **Clean class definitions** - no constructor boilerplate
- **Inline parameter validation** - validate as you use

The Clento backend now works **exactly like your Pocketly system**! üéØ

## **Coding**
- **writing new code**
  - Before writing any new code, scan in the repo if we already have some code for it, do not just blindly create new code, verify if that can be used by modifying a little.
  - When you modify a existing code for new functionality, verify it that code is being use somewhere and does not break that

- **Code Cleanup**
  - Remove unused code, files, and dependencies
  - Delete old implementations when replacing with new ones
  - Always verify code is not used elsewhere before removing it
  - Keep imports clean by removing unused imports
  - Remove commented out code that is no longer needed
  - Document why code is kept if it appears unused but serves a purpose